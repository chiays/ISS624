---
title: "Take-home Exercise 2: Applied Spatial Interaction Models: A case study of Singapore public bus commuter flows"
author: "Chia Yong Soon"
date: "09 Dec 2023"
date-modified: "last-modified"
---

## **1 Setting the Scene**

What are the driving forces behind urban dwellers to weak up early in morning to commute from their home locations to their work places? What are the impact of removing a public bus service on the commuters reside along the corridor of the bus route? These and many other questions related to urban mobility are challenges faced by transport operators and urban managers.

To provide answer to this question, traditionally, commuters survey will be used. However, commuters survey is a very costly, time-consuming and laborous, not to mention that the survey data tend to take a long time to clean and analyse. As a result, it is not unusual, by the time the survey report was ready, most of the information already out-of-date!

As city-wide urban infrastructures such as public buses, mass rapid transits, public utilities and roads become digital, the data sets obtained can be used as a framework for tracking movement patterns through space and time. This is particularly true with the recent trend of massive deployment of pervasive computing technologies such as GPS on the vehicles and SMART cards used by public transport commuters.

Unfortunately, this explosive growth of geospatially-referenced data has far outpaced the planner's ability to utilize and transform the data into insightful information thus creating an adverse impact on the return on the investment made to collect and manage this data.

## **2 Motivation and Objective**

This take-home exercise is motivated by two main reasons. Firstly, despite increasing amounts of open data available for public consumption, there has not been significant practice research carried out to show how these disparate data sources can be integrated, analysed, and modelled to support policy making decisions.

Secondly, there is a general lack of practical research to show how geospatial data science and analysis (GDSA) can be used to support decision-making.

Hence, your task for this take-home exercise is to conduct a case study to demonstrate the potential value of GDSA to integrate publicly available data from multiple sources for building a spatial interaction models to determine factors affecting urban mobility patterns of public bus transit.

## **The Data**

### **Open Government Data**

For the purpose of this assignment, data from several open government sources will be used:

-   *Passenger Volume by Origin Destination Bus Stops*, *Bus Stop Location*, *Train Station* and *Train Station Exit Point*, just to name a few of them, from [LTA DataMall](https://datamall.lta.gov.sg/content/datamall/en.html).

-   *Master Plan 2019 Subzone Boundary*, *HDB Property Information*, *School Directory and Information* and other relevant data from [Data.gov.sg](https://beta.data.gov.sg/).

### **Specially collected data**

-   *Business*, *entertn*, *F&B*, *FinServ*, *Leisure&Recreation* and *Retails* are geospatial data sets of the locations of business establishments, entertainments, food and beverage outlets, financial centres, leisure and recreation centres, retail and services stores/outlets I compiled for urban mobility study. They are available on in the geospatial folder to Take-home Exercise 2 data folder.

-   HDB: This data set is the geocoded version of *HDB Property Information* data from data.gov. The data set is prepared using September 2021 data. If you want to prepare you own data by using the latest *HDB Property Information* provided on data.gov.sg, this [link](https://is415-msty.netlify.app/posts/2021-10-25-take-home-exercise-3/?panelset6=glimpse%28%29#geocoding-our-aspatial-data) provides a useful step-by-step guide.

## **3 The Task**

The specific tasks of this take-home exercise are as follows:

### **Geospatial Data Science**

-   Derive an analytical hexagon data of 325m (this distance is the perpendicular distance between the centre of the hexagon and its edges) to represent the [traffic analysis zone (TAZ)](https://tmg.utoronto.ca/files/Reports/Traffic-Zone-Guidance_March-2021_Final.pdf).

-   With reference to the time intervals provided in the table below, construct an O-D matrix of commuter flows for a time interval of your choice by integrating *Passenger Volume by Origin Destination Bus Stops* and *Bus Stop Location* from [LTA DataMall](https://datamall.lta.gov.sg/content/datamall/en.html). The O-D matrix must be aggregated at the analytics hexagon level

    | Peak hour period             | Bus tap on time |
    |------------------------------|-----------------|
    | Weekday morning peak         | 6am to 9am      |
    | Weekday afternoon peak       | 5pm to 8pm      |
    | Weekend/holiday morning peak | 11am to 2pm     |
    | Weekend/holiday evening peak | 4pm to 7pm      |

-   Display the O-D flows of the passenger trips by using appropriate geovisualisation methods (not more than 5 maps).

-   Describe the spatial patterns revealed by the geovisualisation (not more than 100 words per visual).

-   Assemble at least three propulsive and three attractiveness variables by using aspatial and geospatial from publicly available sources.

-   Compute a distance matrix by using the analytical hexagon data derived earlier.

### **Spatial Interaction Modelling**

-   Calibrate spatial interactive models to determine factors affecting urban commuting flows at the selected time interval.

-   Present the modelling results by using appropriate geovisualisation and graphical visualisation methods. (Not more than 5 visuals)

-   With reference to the Spatial Interaction Model output tables, maps and data visualisation prepared, describe the modelling results. (not more than 100 words per visual).

## 4 Installing and Loading the R Packages

Six R packages will be used for this exercise, they are sf, sfdep, tmap, tidyverse, knitr, plotly.

```{r}
#| code-fold: true 
#| code-summary: "Show the code" 
pacman::p_load(sf, sfdep, tmap, tidyverse, knitr, plotly, httr, stplanr)
```

1.  sf: Purpose: The sf package stands for "simple features" and is used for working with spatial data in R. It provides a framework for representing and manipulating geometric objects like points, lines, and polygons, making it useful for tasks such as geographic information system (GIS) analysis.

2.  sfdep: Purpose: The sfdep provides users with a way to conduct "Exploratory Spatial Data Analysis", typical for exploratory data analysis. It evaluates the phenomena captured in the data on whether they are dependent upon space--or are spatially auto-correlated. "Local Indicators of Spatial Association", LISAs for short are measures that are developed to identify whether some observed pattern is truly random or impacted by its relationship in space.

3.  tmap: Purpose: tmap is a package for creating thematic maps in R. It provides a simple and consistent interface for visualizing spatial data, making it easier to create informative and visually appealing maps. It is often used in conjunction with the sf package for handling spatial data.

4.  tidyverse: Purpose: The tidyverse is not a single package but a collection of R packages that work together cohesively for data manipulation and visualization. It includes popular packages like ggplot2 for plotting, dplyr for data manipulation, tidyr for data tidying, and others. The tidyverse philosophy emphasizes a consistent and intuitive approach to data analysis.

5.  knitr: Purpose: knitr is a package for dynamic report generation in R. It allows you to embed R code directly into documents and then render the code and its output, such as tables and plots, into various document formats like HTML, PDF, or Word. It is commonly used with R Markdown to create reproducible research reports.

6.  plotly: Purpose: plotly is a package for creating interactive and dynamic plots in R. It supports a variety of chart types, including scatter plots, line charts, and 3D plots. The resulting visualizations can be embedded into web pages, making it a powerful tool for creating interactive and shareable data visualizations.

7.  httr: Purpose: httr is a package designed to work with web APIs. It provides functions for sending HTTP requests, handling responses, and interacting with web services. The name "httr" stands for "http tools."

8. stplanr: Purpose stplanr is an package designed for transport planning and analysis. It provides a set of functions and tools for working with spatial data related to transport and infrastructure planning. The package leverages the capabilities of the sf (simple features) package for handling spatial data.



## 5 The Data

### Aspatial data

For the purpose of this take-home exercise, Passenger Volume by Origin Destination Bus Stops downloaded from LTA DataMall will be used.

#### Importing the aspatial data

Since listings data set is in csv file format, we will use read_csv() of readr package to import origin_destination_bus.csv as shown the code chunk below. The output R object is called odbus1023 and it is a tibble data frame.

```{r}
#| code-fold: true 
#| code-summary: "Show the code" 
odbus1023 <- read_csv("data/aspatial/origin_destination_bus_202310.csv")
```

A quick check of odbus tibble data frame shows that the values in OROGIN_PT_CODE and DESTINATON_PT_CODE are in numeric data type.

```{r}
#| code-fold: true 
#| code-summary: "Show the code" 
glimpse(odbus1023)
```

Convert these data values into factor data type.

```{r}
#| code-fold: true 
#| code-summary: "Show the code" 
odbus1023$ORIGIN_PT_CODE <- as.factor(odbus1023$ORIGIN_PT_CODE) 
odbus1023$DESTINATION_PT_CODE <- as.factor(odbus1023$DESTINATION_PT_CODE)
```

Notice that both of them are in factor data type now.

```{r}
#| code-fold: true 
#| code-summary: "Show the code" 
glimpse(odbus1023)
```

#### TASK:- Weekday morning peak (Period: 6am to 9am)

For the purpose of extracting the commuting flows during the weekday morning peak for the period from 6am to 9am. Call the output tibble data table as origin_WDMP and dest_WDMP.

| Peak hour period     | Bus tap on time |
|----------------------|-----------------|
| Weekday morning peak | 6am to 9am      |

```{r}
#| code-fold: true 
#| code-summary: "Show the code" 
origin_WDMP <- odbus1023 %>%   
        filter(DAY_TYPE == "WEEKDAY") %>%   
        filter(TIME_PER_HOUR >= 6 &            
        TIME_PER_HOUR <= 9) %>%   
        group_by(ORIGIN_PT_CODE) %>%   
        summarise(TRIPS = sum(TOTAL_TRIPS))
```

```{r}
#| code-fold: true 
#| code-summary: "Show the code" 
dest_WDMP <- odbus1023 %>%   
        filter(DAY_TYPE == "WEEKDAY") %>%   
        filter(TIME_PER_HOUR >= 6 &            
        TIME_PER_HOUR <= 9) %>%   
        group_by(DESTINATION_PT_CODE) %>%   
        summarise(TRIPS = sum(TOTAL_TRIPS))
```

```{r}
#| code-fold: true 
#| code-summary: "Show the code" 
all_WDMP <- odbus1023 %>%   
        filter(DAY_TYPE == "WEEKDAY") %>%   
        filter(TIME_PER_HOUR >= 6 &            
        TIME_PER_HOUR <= 9) %>%   
        group_by(ORIGIN_PT_CODE,
                 DESTINATION_PT_CODE) %>%   
        summarise(TRIPS = sum(TOTAL_TRIPS))
```

View the top few rows of the summarized trips by ORIGIN_PT_CODE.

```{r}
#| code-fold: true 
#| code-summary: "Show the code" 
head(origin_WDMP)
```

View the top few rows of the summarized trips by DESTINATION_PT_CODE.

```{r}
#| code-fold: true 
#| code-summary: "Show the code" 
head(dest_WDMP)
```

We will save the output in rds format for future used.

```{r}
#| code-fold: true 
#| code-summary: "Show the code" 
write_rds(origin_WDMP, "data/rds/origin_WDMP.rds")
```

```{r}
#| code-fold: true 
#| code-summary: "Show the code" 
write_rds(dest_WDMP, "data/rds/dest_WDMP.rds")
```

```{r}
#| code-fold: true 
#| code-summary: "Show the code" 
write_rds(all_WDMP, "data/rds/all_WDMP.rds")
```

The code chunk below will be used to import the save into R environment.

```{r}
#| code-fold: true 
#| code-summary: "Show the code" 
origin_WDMP <- read_rds("data/rds/origin_WDMP.rds")
dest_WDMP <- read_rds("data/rds/dest_WDMP.rds")
all_WDMP <- read_rds("data/rds/all_WDMP.rds")
```

### Geospatial data

Two geospatial data will be used in this study, they are:

-   Bus Stop Location from LTA DataMall. It provides information about all the bus stops currently being serviced by buses, including the bus stop code (identifier) and location coordinates.

-   hexagon, a hexagon layer of 375m (this distance is the perpendicular distance between the centre of the hexagon and its edges.) should be used to represent the [traffic analysis zone](https://tmg.utoronto.ca/files/Reports/Traffic-Zone-Guidance_March-2021_Final.pdf).

#### Importing the data into R Environment

In this section, you are required to import two shapefile into RStudio, they are: - BusStop: This data provides the location of bus stop as at 2nd quarter of 2023. - MPSZ-2019: This data provides the sub-zone boundary of URA Master Plan 2019.

The code chunk below uses st_read() function of sf package to import BusStop shapefile into R as line feature data frame.

```{r}
#| code-fold: true 
#| code-summary: "Show the code" 
BusStop = st_read(dsn = "data/geospatial",                           
  layer = "BusStop") %>%   
st_transform(crs = 3414)
```

The message above reveals that there are a total of 5161 features and 3 fields in BusStop linestring feature data frame and it is in svy21 projected coordinates system too.

The structure of busstop sf tibble data frame should look as below.

```{r}
#| code-fold: true 
#| code-summary: "Show the code" 
glimpse(BusStop)
```

Import MPSZ-2019 into RStudio and save it as a sf data frame called mpsz.

```{r}
#| code-fold: true 
#| code-summary: "Show the code" 
mpsz <- st_read(dsn = "data/geospatial",                    
  layer = "MPSZ-2019") %>%   
st_transform(crs = 3414)
```

-   st_read() function of sf package is used to import the shapefile into R as sf data frame.
-   st_transform() function of sf package is used to transform the projection to crs 3414.

The structure of mpsz sf tibble data frame should look as below.

```{r}  
#| code-fold: true  
#| code-summary: "Show the code"  
glimpse(mpsz)
```

## 5 Geospatial data wrangling

### Combining Busstop and mpsz

Code chunk below populates the planning subzone code (i.e. SUBZONE_C) of mpsz sf data frame into busstop sf data frame.

```{r}
#| code-fold: true 
#| code-summary: "Show the code" 
busstop_mpsz <- st_intersection(BusStop, mpsz) %>%   
select(BUS_STOP_N, SUBZONE_C) %>%   st_drop_geometry()
```

Before moving to the next step, save the output into rds format.

```{r}
#| code-fold: true 
#| code-summary: "Show the code" 
write_rds(busstop_mpsz, "data/rds/busstop_mpsz.csv")
```

Next, append the planning subzone code from busstop_mpsz data frame onto origin_WDMP (origin & destination) data frame.

```{r}
#| code-fold: true 
#| code-summary: "Show the code" 
origin_SZ <- left_join(origin_WDMP , busstop_mpsz,
            by = c("ORIGIN_PT_CODE" = "BUS_STOP_N")) %>%
  rename(ORIGIN_BS = ORIGIN_PT_CODE,
         ORIGIN_SZ = SUBZONE_C) %>%
  group_by(ORIGIN_SZ) %>%
  summarise(TOT_TRIPS = sum(TRIPS))
```

```{r}
#| code-fold: true 
#| code-summary: "Show the code" 
dest_SZ <- left_join(dest_WDMP , busstop_mpsz,
            by = c("DESTINATION_PT_CODE" = "BUS_STOP_N")) %>%
  rename(DEST_BS = DESTINATION_PT_CODE,
         DEST_SZ = SUBZONE_C) %>%
  group_by(DEST_SZ) %>%
  summarise(TOT_TRIPS = sum(TRIPS))
```

```{r}
#| code-fold: true 
#| code-summary: "Show the code" 
all_SZ <- left_join(all_WDMP , busstop_mpsz,
            by = c("ORIGIN_PT_CODE" = "BUS_STOP_N")) %>%
  rename(ORIGIN_BS = ORIGIN_PT_CODE,
         ORIGIN_SZ = SUBZONE_C,
         DEST_BS = DESTINATION_PT_CODE)
```

```{r}
#| code-fold: true 
#| code-summary: "Show the code" 
all_SZ <- left_join(all_SZ , busstop_mpsz,
            by = c("DEST_BS" = "BUS_STOP_N")) 
```

```{r}
#| code-fold: true 
#| code-summary: "Show the code" 
all_SZ <- all_SZ %>%
  rename(DEST_SZ = SUBZONE_C) %>%
  
  drop_na() %>%
  group_by(ORIGIN_SZ, DEST_SZ) %>%
  summarise(TOT_TRIPS = sum(TRIPS))
```

Next, merge the origin_BS & dest_BS with busstop_mpsz data frame.

```{r}
#| code-fold: true 
#| code-summary: "Show the code" 
origin_BS <- merge(origin_WDMP, busstop_mpsz, by.x = "ORIGIN_PT_CODE", by.y = "BUS_STOP_N", all = TRUE) %>%   
rename(ORIGIN_BS = ORIGIN_PT_CODE, ORIGIN_SZ = SUBZONE_C) %>%   
group_by(ORIGIN_BS)
```

```{r}
#| code-fold: true 
#| code-summary: "Show the code" 
dest_BS <- merge(dest_WDMP, busstop_mpsz, by.x = "DESTINATION_PT_CODE", by.y = "BUS_STOP_N", all = TRUE) %>%   
rename(DEST_BS = DESTINATION_PT_CODE, DEST_SZ = SUBZONE_C) %>%   
group_by(DEST_BS)
```

============== #\| code-fold: true #\| code-summary: "Show the code" origin_SZ \<- left_join(origin_WDAP_5_8 , busstop_mpsz,\
by = c("ORIGIN_PT_CODE" = "BUS_STOP_N")) %\>%\
rename(ORIGIN_BS = ORIGIN_PT_CODE,\
ORIGIN_SZ = SUBZONE_C) %\>%\
group_by(ORIGIN_SZ) %\>%\
summarise(TOT_TRIPS = sum(TRIPS)) ===============

Check for duplicate records

```{r}
#| code-fold: true 
#| code-summary: "Show the code" 
duplicate_origin_BS <- origin_BS %>%   
  group_by_all() %>%   
  filter(n()>1) %>%   
  ungroup()

duplicate_origin_SZ <- origin_SZ %>%   
  group_by_all() %>%   
  filter(n()>1) %>%   
  ungroup()
```

```{r}
#| code-fold: true 
#| code-summary: "Show the code" 
duplicate_dest_BS <- dest_BS %>%   
  group_by_all() %>%   
  filter(n()>1) %>%   
  ungroup()

duplicate_dest_SZ <- dest_SZ %>%   
  group_by_all() %>%   
  filter(n()>1) %>%   
  ungroup()
```

See if any duplicate records.

```{r}
#| code-fold: true 
#| code-summary: "Show the code" 
glimpse(duplicate_origin_BS)
```

```{r}
#| code-fold: true 
#| code-summary: "Show the code" 
glimpse(duplicate_origin_SZ)
```

```{r}
#| code-fold: true 
#| code-summary: "Show the code" 
glimpse(duplicate_dest_BS)
```

```{r}
#| code-fold: true 
#| code-summary: "Show the code" 
glimpse(duplicate_dest_SZ)
```

As shown above, there are duplicates. We can remove duplicate records (if any) with the following code.

```{r}
#| code-fold: true 
#| code-summary: "Show the code" 
origin_BS <- unique(origin_BS)
origin_SZ <- unique(origin_SZ)
```

```{r}
#| code-fold: true 
#| code-summary: "Show the code" 
dest_BS <- unique(dest_BS)
dest_SZ <- unique(dest_SZ)
```

Next, write a code chunk to update od_data data frame with the planning subzone codes.

```{r}
#| code-fold: true 
#| code-summary: "Show the code" 
origintrip_BS <- left_join(BusStop, origin_BS,                            
            by = c("BUS_STOP_N" = "ORIGIN_BS"))
```

```{r}
#| code-fold: true 
#| code-summary: "Show the code"
origintrip_SZ <- left_join(mpsz, 
                           origin_SZ,
                           by = c("SUBZONE_C" = "ORIGIN_SZ"))
```


```{r}
#| code-fold: true 
#| code-summary: "Show the code" 
desttrip_BS <- left_join(BusStop, dest_BS,                            
            by = c("BUS_STOP_N" = "DEST_BS"))
```

```{r}
#| code-fold: true 
#| code-summary: "Show the code"
desttrip_SZ <- left_join(mpsz, 
                           dest_SZ,
                           by = c("SUBZONE_C" = "DEST_SZ"))
```

Drop points without data (i.e. trip)

```{r} 
#| code-fold: true 
#| code-summary: "Show the code"
non_finite_indices <- which(!is.finite(origintrip_BS$TRIPS))
origintrip_BS$TRIPS[!is.finite(origintrip_BS$TRIPS)] <- 0
```


```{r} 
#| code-fold: true 
#| code-summary: "Show the code" 
non_finite_indices <- which(!is.finite(origintrip_SZ$TOT_TRIPS))
origintrip_SZ$TOT_TRIPS[!is.finite(origintrip_SZ$TOT_TRIPS)] <- 0
```

```{r} 
#| code-fold: true 
#| code-summary: "Show the code"
non_finite_indices <- which(!is.finite(desttrip_BS$TRIPS))
desttrip_BS$TRIPS[!is.finite(desttrip_BS$TRIPS)] <- 0
```

```{r} 
#| code-fold: true 
#| code-summary: "Show the code" 
non_finite_indices <- which(!is.finite(desttrip_SZ$TOT_TRIPS))
desttrip_SZ$TOT_TRIPS[!is.finite(desttrip_SZ$TOT_TRIPS)] <- 0
```

## 6 Choropleth Visualisation

Prepare a choropleth map showing the distribution of passenger trips at planning sub-zone level.

```{r}
#| code-fold: true
#| code-summary: "Show the code"
tm_shape(origintrip_BS)+
  tm_symbols(size = 0.5)+
  tm_layout(main.title = "Passenger trips generated at origin bus-stop level",
            main.title.position = "center",
            main.title.size = 1.2,
            legend.height = 0.45, 
            legend.width = 0.35,
            frame = TRUE) +

  tm_compass(type="8star", size = 2) +
  tm_scale_bar() +
  tm_grid(alpha =0.2)
```

```{r}
#| code-fold: true
#| code-summary: "Show the code"
tm_shape(desttrip_BS)+
  tm_symbols(size = 0.5)+
  tm_layout(main.title = "Passenger trips generated at destination bus-stop level",
            main.title.position = "center",
            main.title.size = 1.2,
            legend.height = 0.45, 
            legend.width = 0.35,
            frame = TRUE) +

  tm_compass(type="8star", size = 2) +
  tm_scale_bar() +
  tm_grid(alpha =0.2)
```

```{r}
#| code-fold: true
#| code-summary: "Show the code"
tm_shape(origintrip_SZ)+
  tm_fill("TOT_TRIPS", 
          style = "quantile", 
          palette = "Blues",
          title = "Passenger trips") +
  tm_layout(main.title = "Passenger trips generated at planning sub-zone level (Origin)",
            main.title.position = "center",
            main.title.size = 1,
            legend.height = 0.45, 
            legend.width = 0.35,
            frame = TRUE) +
  tm_borders(alpha = 0.5) +
  tm_compass(type="8star", size = 2) +
  tm_scale_bar() +
  tm_grid(alpha =0.2)
```


```{r}
#| code-fold: true
#| code-summary: "Show the code"
tm_shape(desttrip_SZ)+
  tm_fill("TOT_TRIPS", 
          style = "quantile", 
          palette = "Blues",
          title = "Passenger trips") +
  tm_layout(main.title = "Passenger trips generated at planning sub-zone level (Destination)",
            main.title.position = "center",
            main.title.size = 1,
            legend.height = 0.45, 
            legend.width = 0.35,
            frame = TRUE) +
  tm_borders(alpha = 0.5) +
  tm_compass(type="8star", size = 2) +
  tm_scale_bar() +
  tm_grid(alpha =0.2)
```


## 7 Visualising Spatial Interaction
Prepare a desire line by using stplanr package.

### 7.1 Removing intra-zonal flows
The code chunk below will be used to remove intra-zonal flows.

```{r}
#| code-fold: true
#| code-summary: "Show the code"
all_SZ_R <- all_SZ[all_SZ$ORIGIN_SZ != all_SZ$DEST_SZ,]
```

### 7.2 Creating desire lines
In this code chunk below, od2line() of stplanr package is used to create the desire lines.

```{r}
#| code-fold: true
#| code-summary: "Show the code"
flowLine <- od2line(flow = all_SZ_R, 
                    zones = mpsz,
                    zone_code = "SUBZONE_C")
```

### 7.3 Visualising the desire lines
To visualise the resulting desire lines, the code chunk below is used.

```{r}
#| code-fold: true
#| code-summary: "Show the code"
tm_shape(mpsz) +
  tm_polygons() +
flowLine %>%  
tm_shape() +
  tm_lines(lwd = "TOT_TRIPS",
           style = "quantile",
           scale = c(0.1, 1, 3, 5, 7, 10),
           n = 6,
           alpha = 0.3)
```



When the flow data are very messy and highly skewed like the one shown above, it is wiser to focus on selected flows, for example flow greater than or equal to 5000 as shown below.


```{r}
#| code-fold: true
#| code-summary: "Show the code"
tm_shape(mpsz) +
  tm_polygons() +
flowLine %>%  
  filter(TOT_TRIPS >= 5000) %>%
tm_shape() +
  tm_lines(lwd = "TOT_TRIPS",
           style = "quantile",
           scale = c(0.1, 1, 3, 5, 7, 10),
           n = 6,
           alpha = 0.3)
```